//#include <iostream>
//using namespace std;
//
////C++의 클래스(class)
////C++에서는 C언어에서 사용하던 구조체를 확장해 만든 클래스를 사용합니다.
////키워드 class를 통해 클래스를 설계하고, 클래스 내부에는 변수와
////함수를 같이 보관해 사용할 수 있습니다.
//
////C언어의 구조체(struct)
////키워드 struct를 통해 변수를 만들면, 구조체 안에 변수를 만들어 관리하는
////사용자 정의 타입
////C++에서는 C언어와의 호환성을 위해 남겨놓은 기능
//class Student_cls
//{
//public :
//	string name;
//	int age;
//
//	//클래스 내부에는 함수를 만들 수 있습니다.
//	void Action()
//	{
//
//	}
//private :
//	string address;
//};
//struct Student_str
//{
//	string name;
//	int age;
//};
//int main()
//{
//	Student_cls S_cls; //클래스 선언
//	Student_str S_str; //구조체 선언
//	//구조체 안에 있는 변수(멤버 변수) 사용
//	S_str.name = "이윤학";
//	//클래스 안에 있는 변수 사용
//	S_cls.name = "김기동";
//	//현재 오류가 나고 있다면 클래스에 만들어 놓은 변수가 비공개 상태이기 때문입니다.
//	//해결책 : 보여주고 싶은 부분을 public으로 감싸줍니다.
//	//public과 private를 통해 데이터에 대한 접근 여부를 설계할 수 있습니다.
//	
//	Student_cls S_cls2;
//	Student_str S_str2;
//	S_cls2.name = "임철균";
//	S_str2.name = "김한솔";
//	//클래스 / 구조체가 가지고 있는 변수들은 주로 프로그램을 설계할 때 자주 사용되는 이름들로
//	//구성되어 있는 경우가 많습니다.
//	//일반적인 프로그래밍에서 변수의 이름은 1번만 설계가 가능하나, 클래스/구조체를 이용해
//	//해당 클래스의 변수, 해당 구조체의 변수로 인식해 같은 이름의 변수를 사용할 수 있습니다.
//	
//
//	//객체/ 절차/ 함수형 -> 프로그래밍 설계 기법
//	//객체 지향 프로그래밍(OOP : Object Oriented Programming) : C++ , 클래스
//	//객체(Object) : 실생활에서 사용되는 모든 것들을 객체라고 정의합니다.
//	//프로그램을 구현하고자 할 때, 프로그램의 중심이 되고 프로그램에서 사용되는
//	//가장 중요한 핵심 데이터를 클래스를 통해 생성하고, 이를 하나의 객체로 보는
//	//프로그램 설계 패러다임
//
//	//장점 : 코드에 대한 재사용 , 확장이 쉬움 
//	//		객체들간의 상호작용을 고려해 프로그램에 대한 모델링이 더 쉽게 이루어짐.
//	//		외부에 불필요한 정보를 은닉하여 보안성을 높일 수 있습니다.(클래스 특징)
//
//	//단점 : 절차지향에 비해 느린 속도를 가지고 있습니다.
//	//		 객체가 많다는 건 즉 저장할 내용이 많다는 것
//	//		 이건 결과 호출로 처리하는 절차지향에 비해 메모리 코스트가 높은 편
//
//
//	//절차 지향 프로그래밍(PP : Procedural Programming) : C , (함수, 포인터)
//	//프로시저를 기반으로 작성하는 프로그래밍 설계 방식을 의미합니다. 
//	//프로시저(Procedure)는 함수의 호출을 의미합니다.
//	//프로그램의 순서와 흐름을 먼저 설계하고 필요한 자료구조들과 함수를 설계하는 방식의
//	//프로그래밍 설계 방법론입니다.	
//	//장점 : 컴퓨터의 처리 구조와 유사한 속도가 빠른 방식
//	//       실행 순서에 따라 구현하는 것이라 구현하는 것이 어렵지 않습니다.
//	//단점 : 디버깅(테스트)를 진행하기 어렵습니다.
//	//       유지 보수가 어려운 방식
//	//		 프로토콜(호출 순서)에 따라 정해지기 때문에 코드의 순서가 바뀔 경우
//	//	     동일 결과를 보장받기 어렵습니다.
//
//	//함수형 프로그래밍(FP :Functional Programming) : 알고리즘, 람다식
//	//자료 처리 = 수학적인 함수의 계산
//	//특징 : 대입문은 사용하지 않습니다.
//	//       작은 문제를 해결하기 위한 함수를 작성합니다.
//
//	//함수형 프로그래밍에서 함수는 순수 함수로 설계하며 이를 1급 객체로 간주합니다.
//	//순수 함수 : 부수 효과(Side Effect)가 하나도 없는 함수
//	//부수 효과 : 변수의 값이 변경 / 예외, 오류가 발생해 실행 중단 / IO 발생 / 자료구조 수정 ...
//	//1급 객체 : 변수나 데이터 구조 안에 담을 수 있습니다.
//	//			 파라미터로 전달이 가능합니다.
//	//			 리턴 값으로 사용할 수 있습니다.
//	//			 이름과 상관없이 구별이 가능합니다.
//
//	//(알고리즘 설계 기법)
//	//동적 프로그래밍(DP : Dynamic Programming) : 동적 계획법  , 배열(기존의 계산 값을 저장하기 위한 배열)
//	//--> 기억하고 풀기
//
//	//하나의 큰 문제를 해결하기 위해
//	//여러 개의 작은 문제로 나누어서 그 결과를 저장하고
//	//큰 문제를 해결하는 문제 해결 패러다임
//	// -> 코드에 대한 최적화
//
//	//사용 목적) : 동일한 문제가 여러번 반복되서 비효율적인 계산이 이루어지는 경우
//	//기존에 사용했던 값들을 저장해두고, 그 값이 나올때 작업을 하지 않도록 처리한다면
//	//기존 값은 재사용하면서 연산을 반복할 필요가 없어 전체 반복 진행보다
//	//효율적으로 처리를 진행할 수 있게 됩니다.
//
//	//해당 방식으로 구현이 가능한 경우
//	//1. 작업이 겹치는 부분이 존재할 때
//	//2. 부분적인 선택으로 인해 전체 문제의 최적의 결과를 낼 수 있는 경우
//
//	//구현 방식
//	//1. Bottom - Up : 아래에서부터 계산을 수행해 누적시켜서 큰 문제를 해결합니다.
//	//2. Top - down : 위에서부터 호출을 시작해 결과 값을 재귀를 통해 재활용합니다.(재귀함수)
//
//	return 0;	
//}