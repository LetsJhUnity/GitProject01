//#include <iostream>
//using namespace std;
//
////함수의 유형
////1. 일반 함수(void)
////2. return 함수(void 이외)
////3. 매개변수에 따른 함수 설계(변수, 포인터, 배열, 구조체 , 참조자...)
////4. 함수 오버로딩(이름 동일 , 매개변수 순서, 개수 다름)
////5. 재귀함수(자기 자신을 반복하는 함수)
//
////재귀함수 설계 방식
////1. 종료 조건을 설계합니다.
////2. 작업할 내용을 설계합니다.
////3. 자기 자신을 호출합니다. 이때 종료 조건에 가까워질 수 있도록 작업을 진행합니다.
//
////장점
////1. 반복문을 사용하지 않고 해당 작업을 반복적으로 수행하는 것이 가능합니다.
////2. 하나의 형태로 작업을 하기에 변수의 사용을 줄일 수 있습니다.
////3. 복잡한 로직의 설계를 논리적으로 쉽게 표현하는 것이 가능합니다.
//
////단점
////함수의 호출(call)이 반복적으로 처리되 느린 처리 속도를 가지고 있습니다.
////메모리 영역 중 함수를 저장하는 영역을 스택(stack)이라 부르는데 이 영역은
////임시 저장소입니다.(함수는 호출되고 소멸하는 구조이기 때문)
////이 영역에서 함수의 호출과 제거를 진행해야 하는데 재귀 함수 설계로 인해
////제거 되지 못하고 호출만 계속 되고 있는 경우 메모리를 과다하게 사용하게 되고
////저장 공간이 부족한 상황이 발생 될 수 있습니다.(stack overflow)
////이 문제의 해결을 위해 반드시 종료 조건이 작성되어 있어야 하며
////너무 많은 호출이 진행되지 않도록 전제 조건을 잘 설계해야 합니다.
//
//
////재귀 함수를 이용한 팩토리얼 구현
//// N 팩토리얼은 N!라고 작성하며, N!은 1부터 N까지의 곱을 표현하는 식을 의미합니다.
//
////EX) N = 5   , N! = 1 * 2 * 3* 4 * 5
////   Factorial(5)   5 * 4 * 3 * 2 *1
//
//int Factorial(int N)
//{
//	//팩토리얼의 종료 조건
//	if (N == 1)
//		return N;
//	//어떤 작업이 반복되고 있는가? 5 X 4 X 3 X 2 X 1 즉 N X (N -1)이 반복되고 있다.
//	return N * Factorial(N - 1);
//}
//
////2. 피보나치 수열(Fibonacchi numbers)
////다음과 같은 수열을 피보나치 수열이라고 부릅니다.
////1 1 2 3 5 8 13 21 34 55 ...
////위의 수열의 값을 순서대로 a,b,c라고 할 때 a + b = c를 만족하게 됩니다.
////수열의 N번째 값을 F(N)이라고 표현한다면 위의 식은 F(N) = F(N-1) + F(N-2)로 표현이 가능합니다.
//
//int fibo(int N)
//{
//	//규칙의 시작점 => 종료 조건
//	if (N <= 1)
//		return N;
//	//찾아낸 규칙을 그대로 return합니다.
//	return fibo(N - 1) + fibo(N - 2);
//}
//
////피보나치 수열을 출력할 함수
//void FNumbers(int N)
//{
//	//시작 값은 1이기 때문에 1부터 처리합니다.
//	for (int i = 1; i <= N; i++)
//	{
//		cout << fibo(i) << " ";
//	}
//	//fibo(1) -> 1 
//	//fibo(2) -> f(1) + f(0)
//	//			   1  + f(-1) + f(-2)
//	//fibo(3) 
//	//fibo(4) 
//	//fibo(5)
//	
//
//
//	cout << endl;
//}
//
//int main()
//{
//	int N;
//	cout << "[팩토리얼 계산기] 숫자를 입력해주세요 >> ";
//	cin >> N;
//	cout << N << "!:" << Factorial(N) << endl;
//	//예시) N에 5를 입력했을 경우 (Factorial은 편의상 F로 작성하겠습니다.)
//	// NF를 N이 종료 조건이 아니라고 표현 , NT를 N이 종료 조건임이라고 표현하겠습니다.
//	// 
//	//1. F(5) 호출  NF  -> return  5 * F(4)
//	//2. F(4) 호출  NF  -> return  4 * F(3)
//	//3. F(3) 호출  NF  -> return  3 * F(2)
//	//4. F(2) 호출  NF  -> return  2 * F(1)
//	//5. F(1) 호출  NT  -> return  1
//
//	//그럼 호출이 다 끝난 값을 확인해보면 다음과 같은 식이 return 됩니다.
//	//5*4*3*2*1
//
//	cout << "[피보나치 수열 계산기] 피보나치 수열을 출력하고자 합니다. 몇 개의 수열을 출력하고 싶은지 작성하세요 >> ";
//	cin >> N;
//	FNumbers(N);
//
//
//	return 0;
//}